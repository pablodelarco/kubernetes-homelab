# ============================================
# PLEX MEDIA SERVER CONFIGURATION
# ============================================
# Following GitOps best practices for homelab deployment
# - Longhorn for config storage (persistent, replicated)
# - NFS for media library (shared with Jellyfin)
# - LoadBalancer for direct access (better for streaming than ingress)
# - Intel Quick Sync GPU for hardware transcoding
# - Proper resource limits and health checks
# ============================================

ingress:
  # Disable ingress - Plex works better with direct LoadBalancer access
  # Ingress/proxies can cause issues with remote access and streaming
  enabled: false

pms:
  # Use Longhorn for config storage (persistent, replicated, backed up)
  storageClassName: "longhorn"

  # Config storage size - Plex metadata can grow large with many movies
  configStorage: 10Gi

  # Don't use existing claim - let Helm create it
  configExistingClaim: ""

  # GPU configuration for hardware transcoding
  # Note: We'll use Intel Quick Sync, not NVIDIA
  gpu:
    nvidia:
      enabled: false

  # Resource limits - Plex can use significant resources during transcoding
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 4000m      # Allow up to 4 CPUs for transcoding
      memory: 8Gi     # Plex can use a lot of RAM for transcoding

  # Health checks for Plex
  livenessProbe:
    httpGet:
      path: /identity
      port: 32400
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /identity
      port: 32400
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

# -- A basic image that will convert the configmap to a file in the rclone config volume
# this is ignored if rclone is not enabled
initContainer:
  image:
    # -- The public dockerhub registry
    registry: index.docker.io
    repository: alpine
    # -- If unset use latest
    tag: 3.18.0
    sha: ""
    pullPolicy: IfNotPresent

  # -- A custom script that will be run in an init container to do any setup before the PMS service starts up
  # This will be run every time the pod starts, make sure that some mechanism is included to prevent
  # this from running more than once if it should only be run on the first startup.
  script: ""
  ###
  ### Example init script that will import a pre-existing pms database if one has not already been setup
  ### This pms database must be available through a URL (or some other mechanism to be pulled into the container)
  # script: |-
  #   #!/bin/sh
  #   echo "fetching pre-existing pms database to import..."
  #
  #   if [ -d "/config/Library" ]; then
  #     echo "PMS library already exists, exiting."
  #     exit 0
  #   fi
  #
  #   apk --update add curl
  #   curl http://example.com/pms.tgz -o pms.tgz
  #   tar -xvzf pms.tgz -C /config
  #   cp -r /config/data/Library /config/Library
  #   rm -rf /config/data pms.tgz
  #
  #   echo "Done."

# -- Specify your own runtime class name eg use gpu
runtimeClassName: ""

# -- The settings specific to rclone
rclone:
  # -- If the rclone sidecar should be created
  enabled: false

  # -- The rclone image that should be used
  image:
    # -- The public dockerhub registry
    registry: index.docker.io
    repository: rclone/rclone
    # -- If unset use latest
    tag: 1.62.2
    sha: ""
    pullPolicy: IfNotPresent

  # -- The name of the secret that contains the rclone configuration file.
  # The rclone config key must be called `rclone.conf` in the secret
  #
  # All keys in configSecret will be available in /etc/rclone/. This might
  # be useful if other files are needed, such as a private key for sftp mode.
  configSecret: ""


  # -- The remote drive that should be mounted using rclone
  # this must be in the form of `name:[/optional/path]`
  # this remote will be mounted at `/data/name` in the PMS container
  remotes: []

  # -- If the remote volumes should be mounted as read only
  readOnly: true

  # -- Additional arguments to give to rclone when mounting the volume
  additionalArgs: []

  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- If the service account token should be auto mounted
  automountServiceAccountToken: false
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

statefulSet:
  # -- Optional extra annotations to add to the service resource
  annotations: {}
  # -- Optional extra annotations to add to the pods in the statefulset
  podAnnotations:
    # Allow privileged access for GPU
    container.apparmor.security.beta.kubernetes.io/plex: unconfined

  # Security context for GPU access (same as Jellyfin)
  # Add video (44) and render (993) groups for /dev/dri access
  podSecurityContext:
    supplementalGroups: [44, 993]
    fsGroup: 65534  # nobody group

service:
  type: LoadBalancer
  port: 32400

  # Preserve client source IP for proper remote access
  # This allows Plex to see the real client IP for bandwidth detection
  externalTrafficPolicy: Local

  # Optional extra annotations to add to the service resource
  annotations: {}

# Pin Plex to the beelink node (same as Jellyfin)
# This ensures access to Intel Quick Sync GPU
nodeSelector:
  kubernetes.io/hostname: beelink

tolerations: []

affinity: {}

priorityClassName: ""

# -- Common Labels for all resources created by this chart.
commonLabels: {}

extraEnv:
  # Plex claim token - get a new one from https://www.plex.tv/claim/
  # This is only needed for initial setup (valid for 4 minutes)
  # After first login, you can remove this
  PLEX_CLAIM: ""  # Get new token from https://www.plex.tv/claim/

  # Server hostname
  HOSTNAME: "PlexServer"

  # Timezone
  TZ: "Europe/Madrid"

  # User/Group IDs (nobody:nogroup - same as other media apps)
  PLEX_UID: "65534"
  PLEX_GID: "65534"

  # Allow local network access without authentication (first startup only)
  ALLOWED_NETWORKS: "192.168.1.0/24"

# Mount NFS media library (same as Jellyfin)
extraVolumeMounts:
  - name: media
    mountPath: /data/media_player
  # Mount Intel GPU for hardware transcoding
  - name: dri
    mountPath: /dev/dri

# NFS volume for media library + GPU device
extraVolumes:
  - name: media
    nfs:
      server: 192.168.1.42
      path: /volume1/media_player
  # Intel Quick Sync GPU device
  - name: dri
    hostPath:
      path: /dev/dri
      type: Directory

extraContainers: []
# extraContainers:
#  - name: <container name>
#    args:
#      - ...
#    image: <docker images>
#    imagePullPolicy: IfNotPresent
#    resources:
#      limits:
#        memory: 128Mi
#      requests:
#        cpu: 100m
#        memory: 128Mi
#    volumeMounts:
#      - ...
